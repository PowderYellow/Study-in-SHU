# 课堂笔记

考试：
浅赋值、深赋值
浅拷贝、深拷贝

函数类模板里是否允许含有一个其他的类模板或函数模板
（类模板里可以有新的类模板吗）

函数模板里是否允许有其他的函数定义
（函数模板里可以定义新的函数吗）

数组和函数不能引用
只有常量、变量有引用

模板里面可以含多个未知数据类型，我们是学了简单的一个未知类型

考题：
1）涉及多个交换变量的函数(年年都考)
2）两个字符串函数
3）引用

考试总共有4大题
1、2大题是送分的
3、4考验编程能力

最后一大题，就算写个函数头也是有分的
（向量、复数、矩阵）

4套卷子的第一部分一定要都对



# 历年卷

## 18届面向对象考卷

### 一、判断

1、

如果没有定义任何构造函数，则编译器会自动定义默认构造函数，其形式如 testClass() {}; 

可以看出，编译器自动提供的默认构造函数什么也没有。

如果程序猿没有定义任何构造函数，则编译器会自动定义默认构造函数，其形式如 testClass() {};  可以看出，编译器自动提供的默认构造函数是 啥也没有啊 ；

只要手动定义了构造函数，编译器就不会再提供默认构造函数了。



2、P244	this指针常量

**this指针的用处:**

一个对象的this指针并不是对象本身的一部分，不会影响sizeof(对象)的结果。

this作用域是在类内部，当在类的非静态成员函数中访问类的非静态成员的时候，编译器会自动将对象本身的地址作为一个隐含参数传递给函数。也就是说，即使你没有写上this指针，编译器在编译的时候也是加上this的，它作为非静态成员函数的隐含形参，对各成员的访问均通过this进行。例如，调用date.SetMonth(9) <===> SetMonth(&date, 9)，this帮助完成了这一转换 .

在成员函数内部，我们可以直接使用调用该函数的对象的成员，而无需通过成员访问运算符来做到这一点，因为this所指的正是这个对象。任何对类成员的直接访问都被看成this的隐式使用。

**this的目的总是指向这个对象，所以this是一个常量指针，我们不允许改变this中保存的地址**

①this指针的特性：
a.)this指针的类型：类类型 *const;
b.)this指针并不是对象的一部分，不会影响对象的大小；
c.)this指针是非静态成员函数的第一个隐含指针形参，是编译器自己处理的，我们不能在成员函数的形参中添加this指针的参数定义，也不能在调用时显示传递对象的地址给this指针;



3、P245	常量成员函数

​		常量成员函数是类的成员函数，这种函数的隐含形式参数为指向本对象的常量指针常量(const 类名* const this) ，故在函数体内只能读取但不能修改本对象的任何属性。



4、P263、264	拷贝构造函数

​		局部自动对象（包括值传递的形参对象）在其所在函数每一次调用时创建，函数返回后析构。



5、



6、P340	派生类对基类的兼容性

​		派生类的对象可以初始化（拷贝构造）基类的对象、初始化基类的引用，可以赋值给基类的对象。派生类对象的地址可以初始化基类的指针变量，可以赋值给基类的指针变量。这种特性成为派生类对象对基类对象的初始化及赋值兼容性。



7、P338	派生类的构造与析构

​		基类的私有成员在派生类中是存在的，但是被隔离起来，不能直接访问。



8、P348	抽象类

​		不能创建抽象类的对象；可以定义抽象类的指针变量指向由其派生的具体类的对象；可以声明抽象类的引用，声明引用时必须用其派生的具体类的对象进行初始化。



9、P309	重载运算符

​		C++不允许用户自己定义新的运算符，只能对已有的部分运算符进行重载；不允许改变运算符操作数的个数（自然不允许使用带默认值的参数）；不能改变运算符的运算优先级；不能改变运算符的运算结合方向。



10、P309	重载运算符

​		C++不允许用户自己定义新的运算符，只能对已有的部分运算符进行重载；不允许改变运算符操作数的个数（自然不允许使用带默认值的参数）；不能改变运算符的运算优先级；不能改变运算符的运算结合方向。

### 二、填空

函数模板的格式P175

### 三、阅读程序写出结果及简答题

注意：对象构造与析构的顺序

### 四、完成类的设计



## 17届面向对象考卷(直招)

### 一、判断

1、P244	this指针常量

​		C++编译器为所有非静态成员函数添加了一个隐含的形式参数，其数据类型为指针常量，参数名为C++保留字this，意味着this的指向被锁定不能更改。



2、解释：p能再使用，delete释放的是p指向内存的空间，不过指向有点问题。所以delete之后还是让p指向NULL吧，这也是我们经常应当做的。



3、P251,252	类模板和模板类

​		编译系统并不编译类模板，只有遇到全部确定了的待定数据类型后，由编译系统先自动生成一个实际的类——成为模板类，然后再对该模板类进行编译。



4、P299	友元类

​		可以声明一个类是另一个类的友元，成为友元类。



5、P290	静态成员函数

​		当有具体对象存在时可以采用对象访问成员的方式访问类的静态数据成员（当然还取决于该静态数据成员的访问控制属性）。

​		对象名.静态数据成员名

​		更一般的方法是只用类名而不用对象名。

​		类名::静态数据成员名



6、P309	重载运算符

​		C++不允许用户自己定义新的运算符，只能对已有的部分运算符进行重载；不允许改变运算符操作数的个数（自然不允许使用带默认值的参数）；不能改变运算符的运算优先级；不能改变运算符的运算结合方向。



7、P163	函数调用

​		函数形式参数的生命期存在于函数被调用时，在调用该函数时产生，用实际参数对其进行初始化，函数返回时销毁形式参数。

8、P163	函数调用



9、P338	派生类对象的构造

​		当派生类对象生成的时候会调用构造函数，首先调用基类的构造函数生成基类部分，然后调用自己的构造函数，析构的时候顺序正好相反，先析构自身的然后析构释放派生类的



10、P348	抽象类

​		至少含有一个纯虚函数的类称为抽象类。

​		不能创建抽象类的对象；可以定义抽象类的指针变量指向由其派生的具体类的对象；可以声明抽象类的引用，声明引用时必须用其派生的具体类的对象进行初始化。



### 二、填空

```
using namespace std;
```

注意看 上下类似的代码，有没有引用 **&**

运算符重载注意是友元函数，开头加 **friend**

### 三、阅读程序写出结果及简答题



### 四、完成类的设计





## 17届面向对象考卷

### 一、判断

1、P345	重载运算符的多态性

2、解释：试了一下，p还真能再使用，所以不要理解错了，delete释放的是p指向内存的空间，他自己还活着，不过指向有点问题，所以delete之后还是让p指向NULL吧，这也是我们经常应当做的。

3、sizeof 运算符：以字节为单位返回运算对象的大小（1字节定义为char类型占用的空间大小），若运算对象是类型（如，float），则必须用圆括号将其括起来。

4、P275	冒号语法

5、P252	模板类的编译

6、P289	静态数据成员

7、P316	重载运算符  后++

8、P335	继承

9、P245	两个const的作用

**常量指针**：指向常量的指针，例如const int *p = &a,可以改变p的指向，但是指向的必须是常量。

**指针常量**：就是常指针，例如int * const p = & a ，可以修改p指向的变量的值，但是p的指向改不了。

10、

**首先先给出几个概念：**

**1）类对象在创建时会调用构造函数，在释放是会调用析构函数；**

**2）函数中的局部变量在函数返回后，会由于弹栈从而内存被释放；**

**3）如果函数参数是采用值传递的方式传入类对象，则由于值传递的性质，先调用类复制构造函数产生一个临时对象，然后在函数返回后会调用类析构函数将该临时对象内存释放；**

**所以在对类对象进行参数传递的过程中，采用引用传递是一个正确的方式。**

其实这个坑也说明了一个问题，**复制构造函数为什么是采用引用传递的形式，而不是采用值传递**。假如采用值传递的方式，会导致什么样的后果？（会无限递归调用复制构造函数，当然实际过程中代码是不会通过编译的）

### 二、填空

注意参数的类型

注意：`char *p = new char [strlen(x) +1];` 



### 三、阅读程序写出结果及简答题



### 四、完成类的设计





## 16届面向对象考卷

### 一、判断

1、P241	成员的访问控制

2、P258	构造函数

3、P264	拷贝构造函数

只有在定义初始化时调用构造函数
构造函数不能被直接调用,必须在创建对象时才会自动调用

4、P243 	对象的基本空间

​	  P268 	对象的资源空间

5、P243	对象的基本空间

6、P289-290	静态数据成员

7、

8、P244  	this指针常量

9、P332  	继承

10、P309	重载运算符

### 二、填空



### 三、阅读程序写出结果及简答题



### 四、完成类的设计





## 自己搜集的题目

1.C++中的struct和class有什么区别？
【答案】从语法上讲，class和struct做类型定义时只有两点区别：
(1)默认**继承权限**。如果不明确指定，来自class的继承按照private继承处理，来自struct的继承按照public继承处理；
(2)成员的默认**访问权限**。class的成员默认是private权限，struct默认是public权限。 除了这两点，class和struct基本就是一个东西。语法上没有任何其它区别。
（敲黑板：继承和访问权限不同，struct为public，class为private）



2.“引用”与指针的区别是什么？
【答案】指针通过某个指针变量指向一个对象后，对它所指向的变量间接操作。程序中使用指针，程序的可读性差；而引用本身就是目标变量的别名，对引用的操作就是对目标变量的操作。



3.

`class A {`
`virtual void func1()；`
`void func2();`
`} ；`
`class B: class A`
`{`
`void func1(){`
`cout < < “func1 in class B” < < endl;}`
`virtual void func2(){cout < < “fun2 in class B” < < endl;}`
`}`
A. A中的func1和B中的func2都是虚函数.
B. A中的func1和B中的func2都不是虚函数.
C. A中的func2是虚函数，B中的func1不是虚函数.
D. A中的func2不是虚函数，B中的func1是虚函数.
【答案】A



4.某文件中定义的静态全局变量(或称静态外部变量)其作用域是 ()?
A.只限某个函数 B.本文件 C.跨文件 D.不限制作用域
【答案】B。静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效， 在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用， 因此可以避免在其它源文件中引起错误。

5.C++函数中值的传递方式有哪几种?
【答案】C++函数的三种传递方式为：值传递、指针传递和引用传递。



6.引用与指针有什么区别？
【答案】

1. 引用创建时必须同时被初始化，指针可以在任何时候初始化。
2. 引用初始化后不能改变引用关系，指针能随时改变所指的对象。
3. 不存在指向空值的引用，但是存在指向空值的指针。



7.C++中virtual的含义分别是什么？
【答案】
在基类成员函数的声明前加上virtual关键字，意味着将该成员函数声明为虚函数。
虚函数的特点：如果希望派生类能够重新定义基类的方法，则在基类中将该方法定义为虚方法，这样可以启用动态联编。



8.有了 malloc/free 为什么还要 new/delete？
【答案】
malloc 与 free 是 C++/C 语言的标准库函数，new/delete 是 C++的运算符。它们都可用于申请动态内存和释放内存。 对于非内部数据类型的对象而言，光用 maloc/free 无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于malloc/free 是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加malloc/free。 因此 C++语言需要一个能完成动态内存分配和初始化工作的运算符 new，以及一个能完成清理与释放内存工作的运算符 delete。注意 new/delete 不是库函数。



9.const 符号常量：
(1)const char *p
(2)char const *p
(3)char * const p
说明上面三种描述的区别；

(1)p是一个指向const char的指针，p是可以改变指向的，但是p指向的值是不能改变的;

(2)p指向的恰好是一个指向const的char的普通指针；

(3)p是一个指针，这个指针是指向char的const指针。(1)和(2)的定义是一样的。



10.多态类中的虚函数表是Compile-Time，还是Run-Time时建立的?
【答案】虚拟函数表是在编译期就建立了,各个虚拟函数这时被组织成了一个虚拟函数的入口地址的数组.而对象的隐藏成员–虚拟函数表指针是在运行期–也就是构造函数被调用时进行初始化的,这是实现多态的关键。



11.若数组名作实参而指针变量作形参，函数调用实参传给形参的是()
A.数组的长度
B.数组第一个元素的值
C.数组所有元素的值
D.数组第一个元素的地址
【答案】D



12.变量的指针含意是指变量的 ()
A.值
B.地址
C.存储
D.名字
【答案】B



13.内存的分配方式有几种?
【答案】
（1）从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量。
（2）在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。
（3）从堆上分配，亦称动态内存分配。程序在运行的时候用malloc或new申请任意多少的内存，程序员自己负责在何时用free或delete释放内存。动态内存的生存期由我们决定，使用非常灵活，但问题也最多。



14.全局变量和局部变量有什么区别？是怎么实现的？操作系统和编译器是怎么知道的？
【答案】

生命周期不同：全局变量随主程序创建和创建，随主程序销毁而销毁；局部变量在局部函数内部，甚至局部循环体等内部存在，退出就不存在； 内存中分配在全局数据区。 

使用方式不同：通过声明后全局变量程序的各个部分都可以用到；局部变量只能在局部使用，分配在栈区。 操作系统和编译器通过内存分配的位置来知道的，全局变量分配在全局数据段并且在程序开始运行的时候被加载。局部变量则分配在堆栈里面 。



15.为什么数组名作为参数，会改变数组的内容，而其它类型如int却不会改变变量的值？
【答案】当数组名作为参数时，传递的实际上是地址。而其他类型如int作为参数时，由于函数参数值实质上是实参的一份拷贝，被调函数内部对形参的改变并不影响实参的值。



16.const关键字？有哪些作用
【答案】
const关键字至少有下列n个作用：
（1）欲阻止一个变量被改变，可以使用const关键字。在定义该const变量时，通常需要对它进行初始化，因为以后就没有机会再去改变它了；
（2）对指针来说，可以指定指针本身为const，也可以指定指针所指的数据为const，或二者同时指定为const；
（3）在一个函数声明中，const可以修饰形参，表明它是一个输入参数，在函数内部不能改变其值；
（4）对于类的成员函数，若指定其为const类型，则表明其是一个常函数，不能修改类的成员变量；
（5）对于类的成员函数，有时候必须指定其返回值为const类型，以使得其返回值不为“左值”。



17.是不是一个父类写了一个virtual 函数，如果子类覆盖它的函数不加virtual ,也能实现多态?
【答案】virtual修饰符会被隐形继承的。virtual可加可不加。子类的空间里有父类的所有变量(static除外)。同一个函数只存在一个实体(inline除外)。子类覆盖它的函数不加virtual ,也能实现多态。在子类的空间里，有父类的私有变量。私有变量不能直接访问。



18.面向对象的三个基本特征，并简单叙述之？
【答案】
（1）封装：将客观事物抽象成类，每个类对自身的数据和方法实行protection(private,protected,public)
（2）继承：广义的继承有三种实现形式：实现继承（指使用基类的属性和方法而无需额外编码的能力）、可视继承（子窗体使用父窗体的外观和实现代码）、接口继承（仅使用属性和方法，实现滞后到子类实现）。前两种（类继承）和后一种（对象组合=>接口继承以及纯虚函数）构成了功能复用的两种方式。
（3）多态：是将父对象设置成为和一个或更多的与他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。简单的说，就是一句话：允许将子类类型的指针赋值给父类类型的指针。



19.重载（overload)、重写(override，有的书也叫做“覆盖”）、重定义（redefinition）的区别？
【答案】

| 名称        | 名字空间       | 区别                                               |
| ----------- | -------------- | -------------------------------------------------- |
| 重载        | 同一名字子空间 | 是指允许存在多个同名函数，而这些函数的参数表不同。 |
| 重定义/隐藏 | 不同名字子空间 | 用于继承，派生类与基类的函数同名，屏蔽基类的函数   |
| 重写/覆盖   | 不同名字子空间 | 用于继承，子类重新定义父类虚函数的方法             |

20.多态的作用？
【答案】主要是两个：（1）隐藏实现细节，使得代码能够模块化；扩展代码模块，实现代码重用；（2）接口重用：为了类在继承和派生的时候，保证使用家族中任一类的实例的某一属性时的正确调用。



21.当一个类A 中没有声命任何成员变量与成员函数,这时sizeof(A)的值是多少，如果不是零，请解释一下编译器为什么没有让它为零。
【答案】sizeof(A)= 1。编译器不允许一个类的大小为0，会为它分配1字节的内存。若不这样做，那2个类A的实例在内存中将会无法区分。 一个空类对象的大小是1byte。这是被编译器安插进去的一个字节，这样就使得这个空类的两个实例得以在内存中配置独一无二的地址。



22.如果ClassA中定义并实现虚函数int func(void)，ClassB中也实现该函数，那么上述变量a->func()将调用哪个类里面的函数？如果int func(void)不是虚函数，情况又如何？为什么？
【答案】第一问调用的是B的。第二问调用A的。虚函数的一个典型应用，虚函数只能借助于指针或者引用来达到多态的效果。



23.请讲一讲析构函数和虚函数的用法和作用？
【答案】析构函数是特殊的类成员函数，它没有返回类型，没有参数，不能随意调用，也没有重载，只有在类对象的生命期结束的时候，由系统自动调用，有释放内存空间的作用。虚函数是C++多态的一种表现, 使用虚函数，我们可以灵活的进行动态绑定，当然是以一定的开销为代价。



24.C++程序下列说法正确的有:
A、对调用的虚函数和模板类都进行迟后编译.
B、基类与子类中函数如果要构成虚函数,除了要求在基 类中用virtual 声名,而且必须名字相同且参数类型相同返回类型相同。
C、重载的类成员函数都必须要:或者返回类型不同,或者参数数目不同,或者参数序列的类型不同.
D、静态成员函数和内联函数不能是虚函数,友员函数和构造函数也不能是虚函数,但是析构函数可以是虚函数.
【标准答案】A



25.在C++中有没有纯虚构造函数？
【答案】构造函数不能是虚的。只能有虚的析构函数。



26.在c++的一个类中声明一个static成员变量的用处：
【答案】在C++类的成员变量被声明为static（称为静态成员变量），意味着它为该类的所有实例所共享，也就是说当某个类的实例修改了该静态成员变量，也就是说不管创建多少对象，static修饰的变量只占有一块内存。其修改值为该类的其它所有实例所见；而类的静态成员函数也只能访问静态成员（变量或函数）。static是加了访问控制的全局变量，不被继承。



27.函数模板与类模板有什么区别？
【答案】函数模板的实例化是由编译程序在处理函数调用时自动完成的，而类模板的实例化必须由程序员在程序中显式地指定



28、所有的运算符都能重载吗？
【答案】不能被重载的运算符
在 C++运算符集合中，有一些运算符是不允许被重载的。这种限制是出于安全方面的考虑，可防止错误和混乱。
（1）不能改变 C++内部数据类型（如 int,float 等）的运算符。
（2）不能重载‘.’，因为‘.’在类中对任何成员都有意义，已经成为标准用法。
（3）不能重载目前 C++运算符集合中没有的符号，如#,@,$等。原因有两点，一是难以理解，二是难以确定优先级。
（4）对已经存在的运算符进行重载时，不能改变优先级规则，否则将引起混乱。



29.基类的析构函数不是虚函数，会带来什么问题？
【答案】派生类的析构函数用不上，会造成资源的泄漏。



30.写一个能做左值的函数(方法有很多)。如：
`max(x, y) += 2874 + 55;`
`drwline(x, y)++;`
【答案】

```cpp
int &max(int & x, int & y)
{
     return x > y? x : y;
}
int x = 55, y = 77;
max(x, y) += 12 + 11;                        // 此时 y = 100;
cout << "x = "x << ";y = "<< y << endl;      // 输出 x = 55; y = 100;
```



31.以下三条输出语句分别输出什么？
`char str1[] = “abc”;`
`char str2[] = “abc”;`
`const char str3[] = “abc”;`
`const char str4[] = “abc”;`
`const char* str5 = “abc”;`
`const char* str6 = “abc”;`
`cout << boolalpha << ( str1 == str2 ) << endl; // 输出什么？`
`cout << boolalpha << ( str3 == str4 ) << endl; // 输出什么？`
`cout << boolalpha << ( str5 == str6 ) << endl; // 输出什么？`
【答案】分别输出false,false,true。str1和str2都是字符数组，每个都有其自己的存储区，它们的值则是各存储区首地址，不等；str3和str4同上，只是按const语义，它们所指向的数据区不能修改。str5和str6并非数组而是字符指针，并不分配存储区，其后的“abc”以常量形式存于静态数据区，而它们自己仅是指向该区首地址的指针，相等。



## 重要知识点

#### 1.常量指针和指针常量

**常量指针**：指向常量的指针，例如const int *p = &a,可以改变p的指向，但是指向的必须是常量。

**指针常量**：就是常指针，例如int * const p = & a ，可以修改p指向的变量的值，但是p的指向改不了。



#### 2.函数传参问题

void f(const int &a) 可以传入表达式参数

void f(int &a) 不能传入表达式参数

原因：表达式其实是一个函数，例如a+b返回的其实是个临时变量的值，传值过来就被视为常量，而c++规定引用传参不允许绑定常量，也就是说，引用必须引用的是一个变量，由于传来的是常量，所以不能引用。而前者是常引用，也就意味着可以引用常量，从而解决了表达式传参的问题。

 

#### 3.只传部分参数返回结构体引发的生命周期问题

`struct AA`

`{`

​	  `int x;`

`}`

`AA *f(int a,int b,int c)`

`{`

  	`AA aa;`

 	 `AA * p = &aa;`

 	 `aa.x = a + b +c;`

 	 `return p`

`}`

这个函数显然写的有问题，因为aa的生命周期在函数内，在函数外就没用了，因为返回指向aa的指针是没有意义的。

解决方法：

①动态生成结构体

`A *p = new A();`

这种new出来的结构体生命周期是在你delete之前一直存在的，所以符合要求，不过要记得在main函数执行完了或者在其他地方释放掉内存。

 

②局部静态结构体

`static AA aa;`

在AA aa 前加上static让他成为静态变量，这样生命周期就长于这个函数了，不过这样破坏了C++的局部可见性，不是很推荐。

 

然后其他的引用等方法没必要写了，太常规。



#### 4.Template知识点

template想要处理多个数据类型不同的变量的时候，可以这么定义：

`Template <typename T,typename,P>`



